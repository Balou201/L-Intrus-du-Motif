<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L'Intrus du Motif</title>
    <style>
        :root {
            --primary-bg: #f7fafd; /* Très léger bleu */
            --secondary-bg: #ffffff; /* Fond des conteneurs */
            --text-color: #333;
            --header-color: #2c3e50;
            --grid-memo-border: #a7d9ed;
            --grid-memo-bg: #eaf6fc;
            --grid-cell-bg: #d1e9f7;
            --selection-border: #ffd700; /* Jaune */
            --selection-bg: #fffacd; /* Jaune clair */
            --selection-motif-bg: #ffe082; /* Jaune plus soutenu */
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --timer-color: #d32f2f; /* Rouge */
            --correct-color: #8bc34a; /* Vert */
            --wrong-color: #f44336; /* Rouge */
            --info-color: #555;
            --shadow-light: rgba(0, 0, 0, 0.05);
            --shadow-medium: rgba(0, 0, 0, 0.2);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: var(--primary-bg);
            margin: 0;
            color: var(--text-color);
            overflow-x: hidden; /* Empêche le défilement horizontal */
        }

        h1 {
            color: var(--header-color);
            margin-bottom: 20px; /* Réduit la marge */
            font-size: 3em;
            text-align: center;
            line-height: 1.2;
        }

        #game-container {
            background-color: var(--secondary-bg);
            padding: 30px; /* Réduit le padding */
            border-radius: 20px;
            box-shadow: 0 15px 40px var(--shadow-medium);
            text-align: center;
            width: 90%;
            max-width: 700px;
            box-sizing: border-box; /* Inclut padding et border dans la largeur */
        }

        #game-grid-memo, #intruder-selection {
            display: grid;
            grid-template-columns: repeat(4, 90px);
            grid-template-rows: repeat(4, 90px);
            gap: 10px;
            margin: 25px auto; /* Réduit la marge */
            border: 2px solid var(--grid-memo-border);
            border-radius: 10px;
            padding: 10px;
            background-color: var(--grid-memo-bg);
            width: fit-content;
            max-width: 100%; /* Assure la responsivité */
            box-sizing: border-box;
            justify-content: center; /* Centre la grille horizontalement */
        }

        #intruder-selection {
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); /* Adaptatif */
            grid-template-rows: auto;
            gap: 15px;
            border-color: var(--selection-border);
            background-color: var(--selection-bg);
            padding: 15px;
        }
        
        @media (max-width: 600px) {
            #game-grid-memo, #intruder-selection {
                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
                grid-template-rows: auto;
                gap: 8px;
            }
            .grid-cell, .selection-motif {
                width: auto; /* Permet aux cellules de s'adapter */
                height: 60px;
                font-size: 2.2em;
            }
            #intruder-selection {
                grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            }
            .selection-motif {
                height: 70px;
            }
            h1 {
                font-size: 2.2em;
            }
            #game-container {
                padding: 20px;
            }
        }


        .grid-cell, .selection-motif {
            width: 90px; /* Défaut pour les écrans plus grands */
            height: 90px;
            background-color: var(--grid-cell-bg);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            cursor: default;
            transition: background-color 0.1s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out, opacity 0.5s ease-out; /* Ajout d'opacity pour fade */
            user-select: none;
            box-shadow: inset 0 2px 5px var(--shadow-light);
        }
        
        .grid-cell.hidden-motif {
            opacity: 0; /* Pour l'animation de masquage */
        }

        .selection-motif {
            width: 100px; /* Défaut pour les écrans plus grands */
            height: 100px;
            background-color: var(--selection-motif-bg);
            cursor: pointer;
        }

        .selection-motif:hover {
            transform: scale(1.05);
            background-color: #ffd54f; /* Couleur de survol */
        }

        .selection-motif.correct {
            background-color: var(--correct-color) !important;
            box-shadow: 0 0 15px var(--correct-color);
            cursor: default;
            animation: pulse-correct 0.8s infinite alternate; /* Animation pour la bonne réponse */
        }
        
        @keyframes pulse-correct {
            from { box-shadow: 0 0 15px var(--correct-color); }
            to { box-shadow: 0 0 25px var(--correct-color), 0 0 5px var(--correct-color); }
        }

        .selection-motif.wrong {
            background-color: var(--wrong-color) !important;
            box-shadow: 0 0 15px var(--wrong-color);
            cursor: default;
            animation: shake 0.5s; /* Animation pour la mauvaise réponse */
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        /* Styles pour masquer/afficher les grilles */
        #game-grid-memo { display: none; }
        #intruder-selection { display: none; }
        #intro-screen { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px;}
        #intro-screen p { margin-bottom: 15px; line-height: 1.6; font-size: 1.1em;}

        button.control-button {
            padding: 15px 30px;
            font-size: 1.3em;
            background-color: var(--button-bg);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin: 10px; /* Marge uniforme */
            min-width: 180px; /* Largeur minimale pour uniformité */
        }

        button.control-button:hover:not(:disabled) {
            background-color: var(--button-hover-bg);
            transform: translateY(-2px);
        }

        button.control-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
        }

        #timer-display {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--timer-color);
            margin-bottom: 15px; /* Réduit la marge */
            min-height: 30px;
        }

        #message {
            margin-top: 20px; /* Réduit la marge */
            font-size: 1.4em;
            font-weight: bold;
            min-height: 25px;
            color: var(--text-color);
        }

        #level-info, #game-status {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: var(--info-color);
            font-weight: bold;
        }
        #game-status {
            margin-top: 10px;
            color: var(--header-color);
            font-size: 1.3em;
        }
        #best-score {
            margin-top: 20px;
            font-size: 1.1em;
            color: var(--info-color);
        }
    </style>
</head>
<body>
    <h1>L'Intrus du Motif</h1>
    <div id="game-container">
        <div id="intro-screen">
            <p>Bienvenue dans "L'Intrus du Motif" !</p>
            <p><strong>Règles du jeu :</strong></p>
            <p>1. Une grille de motifs va apparaître pendant quelques secondes. Mémorisez bien tous les motifs et leurs emplacements.</p>
            <p>2. Ensuite, la grille disparaîtra et 5 ou plus motifs apparaîtront. Un seul de ces motifs n'était <strong>PAS</strong> présent dans la grille de mémorisation.</p>
            <p>3. Cliquez sur l'intrus !</p>
            <p>Vous avez <strong><span id="initial-lives">3</span> vies</strong>. Chaque mauvaise réponse vous fera perdre une vie. Accumulez des points et atteignez le plus haut niveau !</p>
            <button id="start-intro-button" class="control-button">Commencer le jeu</button>
        </div>

        <p id="game-status" style="display: none;">Score: 0 | Vies: ❤️❤️❤️</p>
        <p id="level-info" style="display: none;">Niveau : 1</p>
        <p id="timer-display"></p>

        <div id="game-grid-memo"></div>
        <div id="intruder-selection"></div>

        <p id="message"></p>

        <button id="next-round-button" class="control-button" style="display: none;">Niveau Suivant</button>
        <button id="restart-button" class="control-button" style="display: none;">Recommencer</button>
        <p id="best-score" style="display: none;">Meilleur score : 0</p>
    </div>

    <script>
        const gameGridMemo = document.getElementById('game-grid-memo');
        const intruderSelectionDiv = document.getElementById('intruder-selection');
        const messageDisplay = document.getElementById('message');
        const levelInfo = document.getElementById('level-info');
        const timerDisplay = document.getElementById('timer-display');
        const gameStatusDisplay = document.getElementById('game-status');
        const startIntroButton = document.getElementById('start-intro-button');
        const nextRoundButton = document.getElementById('next-round-button');
        const restartButton = document.getElementById('restart-button');
        const introScreen = document.getElementById('intro-screen');
        const bestScoreDisplay = document.getElementById('best-score');
        const initialLivesSpan = document.getElementById('initial-lives'); // Pour afficher les vies initiales dans les règles

        // Une liste de motifs simples (utiliser des emojis pour la démo)
        const allMotifs = ['☀️', '⭐', '🌈', '⚡', '🌸', '🌲', '🍎', '🍓', '💧', '🔥', '💎', '🚀', '🐢', '🦋', '🎈', '🎵', '💡', '⏰', '🔑', '❤️', '🏆', '🎉', '🌟', '🍀', '🍕', '🍦', '🍩', '🍔'];

        const gridSize = 4; // Grille 4x4
        const totalCells = gridSize * gridSize;
        let originalMotifsInGrid = new Set(); // Les motifs présents dans la grille de mémorisation
        let correctIntruderMotif = ''; // Le motif intrus à trouver
        let level = 1;
        let numUniqueMotifs = 3; // Nombre de motifs uniques à placer dans la grille au début (augmentera avec le niveau)
        let memoTime = 8; // Temps de mémorisation en secondes (variera avec le niveau)
        let timerInterval;
        let score = 0;
        let lives = 3;
        const INITIAL_LIVES = 3; // Constante pour les vies initiales
        let bestScore = localStorage.getItem('bestScore') ? parseInt(localStorage.getItem('bestScore')) : 0;

        // Sons du jeu
        const soundCorrect = new Audio('https://www.soundjay.com/buttons/beep-07a.mp3');
        const soundWrong = new Audio('https://www.soundjay.com/buttons/beep-09.mp3');
        const soundTimerTick = new Audio('https://www.soundjay.com/buttons/button-20.mp3'); // Peut être joué en boucle pour les dernières secondes
        const soundGameStart = new Audio('https://www.soundjay.com/buttons/button-10.mp3');
        const soundGameOver = new Audio('https://www.soundjay.com/misc/fail-buzzer-01.mp3');

        // --- Fonctions utilitaires ---

        // Mélange un tableau (Fisher-Yates)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- Fonctions de création / affichage ---

        function createGridCells(container, className) {
            container.innerHTML = ''; // Vide les cellules existantes
            const cells = [];
            for (let i = 0; i < totalCells; i++) {
                const cell = document.createElement('div');
                cell.classList.add(className);
                cell.dataset.id = i;
                container.appendChild(cell);
                cells.push(cell);
            }
            return cells;
        }

        function populateGrid(container, cells, motifsToPlace, randomPlacement = true) {
            cells.forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('hidden-motif'); // Assurez-vous qu'ils sont visibles au début
            });

            const availableCells = Array.from({ length: totalCells }, (_, i) => i);
            shuffleArray(availableCells);

            if (randomPlacement) {
                const motifCounts = {}; // Pour suivre combien de fois chaque motif apparaît
                motifsToPlace.forEach(motif => motifCounts[motif] = 0);

                // Pour s'assurer que chaque motif apparaît au moins une fois et répartir le reste
                let tempAvailableCells = [...availableCells]; // Copie pour placement initial
                for (let i = 0; i < motifsToPlace.length; i++) {
                    const motif = motifsToPlace[i];
                    if (tempAvailableCells.length > 0) {
                        const cellIndex = tempAvailableCells.pop();
                        cells[cellIndex].textContent = motif;
                        motifCounts[motif]++;
                        // Retirer de la liste principale pour éviter de le replacer ici par hasard
                        const originalIndex = availableCells.indexOf(cellIndex);
                        if (originalIndex > -1) {
                            availableCells.splice(originalIndex, 1);
                        }
                    }
                }

                // Placer les motifs restants aléatoirement, garantissant une apparition minimum
                const remainingCells = shuffleArray(availableCells); // Mélanger les cellules restantes
                let motifIndex = 0;
                while (remainingCells.length > 0) {
                    const motif = motifsToPlace[motifIndex % motifsToPlace.length]; // Boucle sur les motifs
                    const cellIndex = remainingCells.pop();
                    cells[cellIndex].textContent = motif;
                    motifCounts[motif]++;
                    motifIndex++;
                }
            } else {
                // Pour la sélection des intrus, on affiche dans l'ordre
                motifsToPlace.forEach((motif, index) => {
                    if (cells[index]) { // S'assurer que la cellule existe
                        cells[index].textContent = motif;
                    }
                });
            }
        }


        // --- Logique du jeu ---

        async function startMemorizationPhase() {
            soundGameStart.play();
            introScreen.style.display = 'none'; // Masque l'écran d'intro
            gameStatusDisplay.style.display = 'block'; // Affiche le score/vies
            levelInfo.style.display = 'block'; // Affiche le niveau
            messageDisplay.textContent = 'Mémorisez les motifs et leurs emplacements !';
            timerDisplay.style.color = 'var(--timer-color)';
            disableButtons();

            gameGridMemo.style.display = 'grid';
            intruderSelectionDiv.style.display = 'none';

            // 1. Déterminer les paramètres du niveau
            memoTime = Math.max(3, 8 - Math.floor((level - 1) / 2)); // Diminue le temps toutes les 2 niveaux, min 3s
            numUniqueMotifs = Math.min(allMotifs.length - 2, 3 + Math.floor((level - 1) / 2)); // Augmente les motifs toutes les 2 niveaux, max allMotifs.length-2

            // 2. Choisir les motifs uniques pour ce round
            const shuffledAllMotifs = shuffleArray([...allMotifs]);
            const selectedUniqueMotifs = shuffledAllMotifs.slice(0, numUniqueMotifs);
            originalMotifsInGrid = new Set(selectedUniqueMotifs); // Garde une trace des motifs présents

            // 3. Remplir la grille de mémorisation avec ces motifs
            const memoCells = createGridCells(gameGridMemo, 'grid-cell');
            populateGrid(gameGridMemo, memoCells, selectedUniqueMotifs, true);

            // 4. Lancer le compte à rebours
            let timeLeft = memoTime;
            timerDisplay.textContent = `Temps : ${timeLeft}s`;
            timerInterval = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = `Temps : ${timeLeft}s`;
                if (timeLeft <= 3 && timeLeft > 0) {
                    soundTimerTick.currentTime = 0; // Réinitialise le son si besoin
                    soundTimerTick.play();
                }
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    timerDisplay.textContent = '';
                    // Ajouter un petit délai pour l'animation de masquage
                    memoCells.forEach(cell => cell.classList.add('hidden-motif')); // Fait disparaître les motifs
                    setTimeout(startSelectionPhase, 600); // Laisse le temps à l'opacité de s'animer
                }
            }, 1000);
        }

        function startSelectionPhase() {
            messageDisplay.textContent = 'Trouvez le motif intrus !';
            gameGridMemo.style.display = 'none';
            intruderSelectionDiv.style.display = 'grid';

            // 1. Choisir 4 motifs de la grille originale + 1 intrus (ou plus pour les niveaux supérieurs)
            const numSelectionOptions = Math.min(allMotifs.length, 5 + Math.floor((level - 1) / 3)); // Augmente le nombre de choix
            
            const motifsForSelection = shuffleArray(Array.from(originalMotifsInGrid)).slice(0, numSelectionOptions - 1);

            // Trouver un intrus qui n'était ABSOLUMENT PAS dans la grille
            let potentialIntruder;
            const availableIntruders = allMotifs.filter(motif => !originalMotifsInGrid.has(motif));
            
            if (availableIntruders.length === 0) {
                // Cas d'urgence si tous les motifs sont dans la grille (ne devrait pas arriver avec allMotifs assez grand)
                potentialIntruder = '❓'; // Un motif de secours
            } else {
                potentialIntruder = shuffleArray(availableIntruders)[0];
            }
            
            correctIntruderMotif = potentialIntruder;
            motifsForSelection.push(correctIntruderMotif);
            shuffleArray(motifsForSelection); // Mélanger les motifs avant de les afficher

            // 2. Afficher les motifs pour la sélection
            intruderSelectionDiv.innerHTML = ''; // Nettoyer avant d'ajouter
            motifsForSelection.forEach((motif) => {
                const cell = document.createElement('div');
                cell.classList.add('selection-motif');
                cell.textContent = motif;
                cell.dataset.motif = motif;
                cell.addEventListener('click', handleSelectionClick);
                intruderSelectionDiv.appendChild(cell);
            });
        }

        function handleSelectionClick(event) {
            const clickedMotif = event.target.dataset.motif;
            
            // Désactiver tous les clics après la première tentative
            Array.from(intruderSelectionDiv.children).forEach(cell => cell.removeEventListener('click', handleSelectionClick));
            disableButtons(); // Désactiver les boutons de contrôle pendant le feedback

            if (clickedMotif === correctIntruderMotif) {
                soundCorrect.play();
                messageDisplay.textContent = 'Correct ! Vous avez trouvé l\'intrus.';
                messageDisplay.style.color = 'var(--correct-color)';
                event.target.classList.add('correct');
                score += 100 + (level * 10); // Gagne plus de points avec le niveau
                level++;
                levelInfo.textContent = `Niveau : ${level}`;
                
                updateGameStatus();
                nextRoundButton.style.display = 'inline-block';
                nextRoundButton.disabled = false;
            } else {
                soundWrong.play();
                messageDisplay.textContent = `Faux ! L'intrus était "${correctIntruderMotif}".`;
                messageDisplay.style.color = 'var(--wrong-color)';
                event.target.classList.add('wrong');
                lives--;
                updateGameStatus();

                // Montre quel était le bon intrus
                Array.from(intruderSelectionDiv.children).forEach(cell => {
                    if (cell.dataset.motif === correctIntruderMotif) {
                        cell.classList.add('correct');
                    }
                });
                
                if (lives <= 0) {
                    soundGameOver.play();
                    messageDisplay.textContent = `Game Over ! Votre score final est ${score}.`;
                    messageDisplay.style.color = '#e74c3c'; // Rouge plus foncé pour Game Over
                    if (score > bestScore) {
                        bestScore = score;
                        localStorage.setItem('bestScore', bestScore);
                        bestScoreDisplay.textContent = `Nouveau meilleur score : ${bestScore}`;
                        bestScoreDisplay.style.display = 'block';
                    }
                    restartButton.style.display = 'inline-block';
                    restartButton.disabled = false;
                } else {
                    nextRoundButton.textContent = "Continuer"; // Changer le texte pour continuer après une erreur
                    nextRoundButton.style.display = 'inline-block';
                    nextRoundButton.disabled = false;
                    restartButton.style.display = 'inline-block'; // Option de redémarrer à tout moment
                    restartButton.disabled = false;
                }
            }
        }

        // --- Gestion des boutons et initialisation ---

        function disableButtons() {
            startIntroButton.disabled = true;
            nextRoundButton.disabled = true;
            restartButton.disabled = true;
        }

        function enableButtons() {
            startIntroButton.disabled = false;
            nextRoundButton.disabled = false;
            restartButton.disabled = false;
        }

        function updateGameStatus() {
            let hearts = '❤️'.repeat(lives) + '🖤'.repeat(INITIAL_LIVES - lives); // Cœurs pleins/vides
            gameStatusDisplay.textContent = `Score: ${score} | Vies: ${hearts}`;
            bestScoreDisplay.textContent = `Meilleur score : ${bestScore}`;
        }

        function resetGame() {
            level = 1;
            numUniqueMotifs = 3;
            memoTime = 8;
            score = 0;
            lives = INITIAL_LIVES;
            levelInfo.textContent = `Niveau : ${level}`;
            messageDisplay.textContent = ''; // Vide le message après redémarrage
            timerDisplay.textContent = '';
            gameGridMemo.style.display = 'none';
            intruderSelectionDiv.style.display = 'none';
            clearInterval(timerInterval); // Arrête tout timer en cours
            
            // Réinitialise l'affichage et les boutons pour l'écran d'intro
            introScreen.style.display = 'flex';
            gameStatusDisplay.style.display = 'none';
            levelInfo.style.display = 'none';
            nextRoundButton.style.display = 'none';
            restartButton.style.display = 'none';
            bestScoreDisplay.style.display = 'block'; // Affiche toujours le meilleur score sur l'écran d'accueil
            nextRoundButton.textContent = "Niveau Suivant"; // S'assurer que le texte du bouton est correct pour le prochain round

            updateGameStatus(); // Met à jour l'affichage des vies/score
            enableButtons(); // Active les boutons de l'écran d'accueil
        }

        // Écouteurs d'événements
        startIntroButton.addEventListener('click', startMemorizationPhase);
        nextRoundButton.addEventListener('click', startMemorizationPhase);
        restartButton.addEventListener('click', resetGame);

        // Initialisation au chargement
        document.addEventListener('DOMContentLoaded', () => {
            initialLivesSpan.textContent = INITIAL_LIVES; // Met à jour le nombre de vies dans les règles
            updateGameStatus(); // Met à jour l'affichage initial du score/vies
            bestScoreDisplay.style.display = 'block'; // Affiche le meilleur score dès le début
            // S'assurer que le bouton de démarrage est actif
            startIntroButton.disabled = false;
        });
    </script>
</body>
</html>
