<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L'Intrus du Motif</title>
    <style>
        :root {
            --primary-bg: #f7fafd; /* Tr√®s l√©ger bleu */
            --secondary-bg: #ffffff; /* Fond des conteneurs */
            --text-color: #333;
            --header-color: #2c3e50;
            --grid-memo-border: #a7d9ed;
            --grid-memo-bg: #eaf6fc;
            --grid-cell-bg: #d1e9f7;
            --selection-border: #ffd700; /* Jaune */
            --selection-bg: #fffacd; /* Jaune clair */
            --selection-motif-bg: #ffe082; /* Jaune plus soutenu */
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --timer-color: #d32f2f; /* Rouge */
            --correct-color: #8bc34a; /* Vert */
            --wrong-color: #f44336; /* Rouge */
            --info-color: #555;
            --shadow-light: rgba(0, 0, 0, 0.05);
            --shadow-medium: rgba(0, 0, 0, 0.2);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: var(--primary-bg);
            margin: 0;
            color: var(--text-color);
            overflow-x: hidden; /* Emp√™che le d√©filement horizontal */
        }

        h1 {
            color: var(--header-color);
            margin-bottom: 20px; /* R√©duit la marge */
            font-size: 3em;
            text-align: center;
            line-height: 1.2;
        }

        #game-container {
            background-color: var(--secondary-bg);
            padding: 30px; /* R√©duit le padding */
            border-radius: 20px;
            box-shadow: 0 15px 40px var(--shadow-medium);
            text-align: center;
            width: 90%;
            max-width: 700px;
            box-sizing: border-box; /* Inclut padding et border dans la largeur */
        }

        #game-grid-memo, #intruder-selection {
            display: grid;
            grid-template-columns: repeat(4, 90px);
            grid-template-rows: repeat(4, 90px);
            gap: 10px;
            margin: 25px auto; /* R√©duit la marge */
            border: 2px solid var(--grid-memo-border);
            border-radius: 10px;
            padding: 10px;
            background-color: var(--grid-memo-bg);
            width: fit-content;
            max-width: 100%; /* Assure la responsivit√© */
            box-sizing: border-box;
            justify-content: center; /* Centre la grille horizontalement */
        }

        #intruder-selection {
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); /* Adaptatif */
            grid-template-rows: auto;
            gap: 15px;
            border-color: var(--selection-border);
            background-color: var(--selection-bg);
            padding: 15px;
        }
        
        @media (max-width: 600px) {
            #game-grid-memo, #intruder-selection {
                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
                grid-template-rows: auto;
                gap: 8px;
            }
            .grid-cell, .selection-motif {
                width: auto; /* Permet aux cellules de s'adapter */
                height: 60px;
                font-size: 2.2em;
            }
            #intruder-selection {
                grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            }
            .selection-motif {
                height: 70px;
            }
            h1 {
                font-size: 2.2em;
            }
            #game-container {
                padding: 20px;
            }
        }


        .grid-cell, .selection-motif {
            width: 90px; /* D√©faut pour les √©crans plus grands */
            height: 90px;
            background-color: var(--grid-cell-bg);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            cursor: default;
            transition: background-color 0.1s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out, opacity 0.5s ease-out; /* Ajout d'opacity pour fade */
            user-select: none;
            box-shadow: inset 0 2px 5px var(--shadow-light);
        }
        
        .grid-cell.hidden-motif {
            opacity: 0; /* Pour l'animation de masquage */
        }

        .selection-motif {
            width: 100px; /* D√©faut pour les √©crans plus grands */
            height: 100px;
            background-color: var(--selection-motif-bg);
            cursor: pointer;
        }

        .selection-motif:hover {
            transform: scale(1.05);
            background-color: #ffd54f; /* Couleur de survol */
        }

        .selection-motif.correct {
            background-color: var(--correct-color) !important;
            box-shadow: 0 0 15px var(--correct-color);
            cursor: default;
            animation: pulse-correct 0.8s infinite alternate; /* Animation pour la bonne r√©ponse */
        }
        
        @keyframes pulse-correct {
            from { box-shadow: 0 0 15px var(--correct-color); }
            to { box-shadow: 0 0 25px var(--correct-color), 0 0 5px var(--correct-color); }
        }

        .selection-motif.wrong {
            background-color: var(--wrong-color) !important;
            box-shadow: 0 0 15px var(--wrong-color);
            cursor: default;
            animation: shake 0.5s; /* Animation pour la mauvaise r√©ponse */
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        /* Styles pour masquer/afficher les grilles */
        #game-grid-memo { display: none; }
        #intruder-selection { display: none; }
        #intro-screen { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px;}
        #intro-screen p { margin-bottom: 15px; line-height: 1.6; font-size: 1.1em;}

        button.control-button {
            padding: 15px 30px;
            font-size: 1.3em;
            background-color: var(--button-bg);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin: 10px; /* Marge uniforme */
            min-width: 180px; /* Largeur minimale pour uniformit√© */
        }

        button.control-button:hover:not(:disabled) {
            background-color: var(--button-hover-bg);
            transform: translateY(-2px);
        }

        button.control-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
        }

        #timer-display {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--timer-color);
            margin-bottom: 15px; /* R√©duit la marge */
            min-height: 30px;
        }

        #message {
            margin-top: 20px; /* R√©duit la marge */
            font-size: 1.4em;
            font-weight: bold;
            min-height: 25px;
            color: var(--text-color);
        }

        #level-info, #game-status {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: var(--info-color);
            font-weight: bold;
        }
        #game-status {
            margin-top: 10px;
            color: var(--header-color);
            font-size: 1.3em;
        }
        #best-score {
            margin-top: 20px;
            font-size: 1.1em;
            color: var(--info-color);
        }
    </style>
</head>
<body>
    <h1>L'Intrus du Motif</h1>
    <div id="game-container">
        <div id="intro-screen">
            <p>Bienvenue dans "L'Intrus du Motif" !</p>
            <p><strong>R√®gles du jeu :</strong></p>
            <p>1. Une grille de motifs va appara√Ætre pendant quelques secondes. M√©morisez bien tous les motifs et leurs emplacements.</p>
            <p>2. Ensuite, la grille dispara√Ætra et 5 ou plus motifs appara√Ætront. Un seul de ces motifs n'√©tait <strong>PAS</strong> pr√©sent dans la grille de m√©morisation.</p>
            <p>3. Cliquez sur l'intrus !</p>
            <p>Vous avez <strong><span id="initial-lives">3</span> vies</strong>. Chaque mauvaise r√©ponse vous fera perdre une vie. Accumulez des points et atteignez le plus haut niveau !</p>
            <button id="start-intro-button" class="control-button">Commencer le jeu</button>
        </div>

        <p id="game-status" style="display: none;">Score: 0 | Vies: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</p>
        <p id="level-info" style="display: none;">Niveau : 1</p>
        <p id="timer-display"></p>

        <div id="game-grid-memo"></div>
        <div id="intruder-selection"></div>

        <p id="message"></p>

        <button id="next-round-button" class="control-button" style="display: none;">Niveau Suivant</button>
        <button id="restart-button" class="control-button" style="display: none;">Recommencer</button>
        <p id="best-score" style="display: none;">Meilleur score : 0</p>
    </div>

    <script>
        const gameGridMemo = document.getElementById('game-grid-memo');
        const intruderSelectionDiv = document.getElementById('intruder-selection');
        const messageDisplay = document.getElementById('message');
        const levelInfo = document.getElementById('level-info');
        const timerDisplay = document.getElementById('timer-display');
        const gameStatusDisplay = document.getElementById('game-status');
        const startIntroButton = document.getElementById('start-intro-button');
        const nextRoundButton = document.getElementById('next-round-button');
        const restartButton = document.getElementById('restart-button');
        const introScreen = document.getElementById('intro-screen');
        const bestScoreDisplay = document.getElementById('best-score');
        const initialLivesSpan = document.getElementById('initial-lives'); // Pour afficher les vies initiales dans les r√®gles

        // Une liste de motifs simples (utiliser des emojis pour la d√©mo)
        const allMotifs = ['‚òÄÔ∏è', '‚≠ê', 'üåà', '‚ö°', 'üå∏', 'üå≤', 'üçé', 'üçì', 'üíß', 'üî•', 'üíé', 'üöÄ', 'üê¢', 'ü¶ã', 'üéà', 'üéµ', 'üí°', '‚è∞', 'üîë', '‚ù§Ô∏è', 'üèÜ', 'üéâ', 'üåü', 'üçÄ', 'üçï', 'üç¶', 'üç©', 'üçî'];

        const gridSize = 4; // Grille 4x4
        const totalCells = gridSize * gridSize;
        let originalMotifsInGrid = new Set(); // Les motifs pr√©sents dans la grille de m√©morisation
        let correctIntruderMotif = ''; // Le motif intrus √† trouver
        let level = 1;
        let numUniqueMotifs = 3; // Nombre de motifs uniques √† placer dans la grille au d√©but (augmentera avec le niveau)
        let memoTime = 8; // Temps de m√©morisation en secondes (variera avec le niveau)
        let timerInterval;
        let score = 0;
        let lives = 3;
        const INITIAL_LIVES = 3; // Constante pour les vies initiales
        let bestScore = localStorage.getItem('bestScore') ? parseInt(localStorage.getItem('bestScore')) : 0;

        // Sons du jeu
        const soundCorrect = new Audio('https://www.soundjay.com/buttons/beep-07a.mp3');
        const soundWrong = new Audio('https://www.soundjay.com/buttons/beep-09.mp3');
        const soundTimerTick = new Audio('https://www.soundjay.com/buttons/button-20.mp3'); // Peut √™tre jou√© en boucle pour les derni√®res secondes
        const soundGameStart = new Audio('https://www.soundjay.com/buttons/button-10.mp3');
        const soundGameOver = new Audio('https://www.soundjay.com/misc/fail-buzzer-01.mp3');

        // --- Fonctions utilitaires ---

        // M√©lange un tableau (Fisher-Yates)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- Fonctions de cr√©ation / affichage ---

        function createGridCells(container, className) {
            container.innerHTML = ''; // Vide les cellules existantes
            const cells = [];
            for (let i = 0; i < totalCells; i++) {
                const cell = document.createElement('div');
                cell.classList.add(className);
                cell.dataset.id = i;
                container.appendChild(cell);
                cells.push(cell);
            }
            return cells;
        }

        function populateGrid(container, cells, motifsToPlace, randomPlacement = true) {
            cells.forEach(cell => {
                cell.textContent = '';
                cell.classList.remove('hidden-motif'); // Assurez-vous qu'ils sont visibles au d√©but
            });

            const availableCells = Array.from({ length: totalCells }, (_, i) => i);
            shuffleArray(availableCells);

            if (randomPlacement) {
                const motifCounts = {}; // Pour suivre combien de fois chaque motif appara√Æt
                motifsToPlace.forEach(motif => motifCounts[motif] = 0);

                // Pour s'assurer que chaque motif appara√Æt au moins une fois et r√©partir le reste
                let tempAvailableCells = [...availableCells]; // Copie pour placement initial
                for (let i = 0; i < motifsToPlace.length; i++) {
                    const motif = motifsToPlace[i];
                    if (tempAvailableCells.length > 0) {
                        const cellIndex = tempAvailableCells.pop();
                        cells[cellIndex].textContent = motif;
                        motifCounts[motif]++;
                        // Retirer de la liste principale pour √©viter de le replacer ici par hasard
                        const originalIndex = availableCells.indexOf(cellIndex);
                        if (originalIndex > -1) {
                            availableCells.splice(originalIndex, 1);
                        }
                    }
                }

                // Placer les motifs restants al√©atoirement, garantissant une apparition minimum
                const remainingCells = shuffleArray(availableCells); // M√©langer les cellules restantes
                let motifIndex = 0;
                while (remainingCells.length > 0) {
                    const motif = motifsToPlace[motifIndex % motifsToPlace.length]; // Boucle sur les motifs
                    const cellIndex = remainingCells.pop();
                    cells[cellIndex].textContent = motif;
                    motifCounts[motif]++;
                    motifIndex++;
                }
            } else {
                // Pour la s√©lection des intrus, on affiche dans l'ordre
                motifsToPlace.forEach((motif, index) => {
                    if (cells[index]) { // S'assurer que la cellule existe
                        cells[index].textContent = motif;
                    }
                });
            }
        }


        // --- Logique du jeu ---

        async function startMemorizationPhase() {
            soundGameStart.play();
            introScreen.style.display = 'none'; // Masque l'√©cran d'intro
            gameStatusDisplay.style.display = 'block'; // Affiche le score/vies
            levelInfo.style.display = 'block'; // Affiche le niveau
            messageDisplay.textContent = 'M√©morisez les motifs et leurs emplacements !';
            timerDisplay.style.color = 'var(--timer-color)';
            disableButtons();

            gameGridMemo.style.display = 'grid';
            intruderSelectionDiv.style.display = 'none';

            // 1. D√©terminer les param√®tres du niveau
            memoTime = Math.max(3, 8 - Math.floor((level - 1) / 2)); // Diminue le temps toutes les 2 niveaux, min 3s
            numUniqueMotifs = Math.min(allMotifs.length - 2, 3 + Math.floor((level - 1) / 2)); // Augmente les motifs toutes les 2 niveaux, max allMotifs.length-2

            // 2. Choisir les motifs uniques pour ce round
            const shuffledAllMotifs = shuffleArray([...allMotifs]);
            const selectedUniqueMotifs = shuffledAllMotifs.slice(0, numUniqueMotifs);
            originalMotifsInGrid = new Set(selectedUniqueMotifs); // Garde une trace des motifs pr√©sents

            // 3. Remplir la grille de m√©morisation avec ces motifs
            const memoCells = createGridCells(gameGridMemo, 'grid-cell');
            populateGrid(gameGridMemo, memoCells, selectedUniqueMotifs, true);

            // 4. Lancer le compte √† rebours
            let timeLeft = memoTime;
            timerDisplay.textContent = `Temps : ${timeLeft}s`;
            timerInterval = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = `Temps : ${timeLeft}s`;
                if (timeLeft <= 3 && timeLeft > 0) {
                    soundTimerTick.currentTime = 0; // R√©initialise le son si besoin
                    soundTimerTick.play();
                }
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    timerDisplay.textContent = '';
                    // Ajouter un petit d√©lai pour l'animation de masquage
                    memoCells.forEach(cell => cell.classList.add('hidden-motif')); // Fait dispara√Ætre les motifs
                    setTimeout(startSelectionPhase, 600); // Laisse le temps √† l'opacit√© de s'animer
                }
            }, 1000);
        }

        function startSelectionPhase() {
            messageDisplay.textContent = 'Trouvez le motif intrus !';
            gameGridMemo.style.display = 'none';
            intruderSelectionDiv.style.display = 'grid';

            // 1. Choisir 4 motifs de la grille originale + 1 intrus (ou plus pour les niveaux sup√©rieurs)
            const numSelectionOptions = Math.min(allMotifs.length, 5 + Math.floor((level - 1) / 3)); // Augmente le nombre de choix
            
            const motifsForSelection = shuffleArray(Array.from(originalMotifsInGrid)).slice(0, numSelectionOptions - 1);

            // Trouver un intrus qui n'√©tait ABSOLUMENT PAS dans la grille
            let potentialIntruder;
            const availableIntruders = allMotifs.filter(motif => !originalMotifsInGrid.has(motif));
            
            if (availableIntruders.length === 0) {
                // Cas d'urgence si tous les motifs sont dans la grille (ne devrait pas arriver avec allMotifs assez grand)
                potentialIntruder = '‚ùì'; // Un motif de secours
            } else {
                potentialIntruder = shuffleArray(availableIntruders)[0];
            }
            
            correctIntruderMotif = potentialIntruder;
            motifsForSelection.push(correctIntruderMotif);
            shuffleArray(motifsForSelection); // M√©langer les motifs avant de les afficher

            // 2. Afficher les motifs pour la s√©lection
            intruderSelectionDiv.innerHTML = ''; // Nettoyer avant d'ajouter
            motifsForSelection.forEach((motif) => {
                const cell = document.createElement('div');
                cell.classList.add('selection-motif');
                cell.textContent = motif;
                cell.dataset.motif = motif;
                cell.addEventListener('click', handleSelectionClick);
                intruderSelectionDiv.appendChild(cell);
            });
        }

        function handleSelectionClick(event) {
            const clickedMotif = event.target.dataset.motif;
            
            // D√©sactiver tous les clics apr√®s la premi√®re tentative
            Array.from(intruderSelectionDiv.children).forEach(cell => cell.removeEventListener('click', handleSelectionClick));
            disableButtons(); // D√©sactiver les boutons de contr√¥le pendant le feedback

            if (clickedMotif === correctIntruderMotif) {
                soundCorrect.play();
                messageDisplay.textContent = 'Correct ! Vous avez trouv√© l\'intrus.';
                messageDisplay.style.color = 'var(--correct-color)';
                event.target.classList.add('correct');
                score += 100 + (level * 10); // Gagne plus de points avec le niveau
                level++;
                levelInfo.textContent = `Niveau : ${level}`;
                
                updateGameStatus();
                nextRoundButton.style.display = 'inline-block';
                nextRoundButton.disabled = false;
            } else {
                soundWrong.play();
                messageDisplay.textContent = `Faux ! L'intrus √©tait "${correctIntruderMotif}".`;
                messageDisplay.style.color = 'var(--wrong-color)';
                event.target.classList.add('wrong');
                lives--;
                updateGameStatus();

                // Montre quel √©tait le bon intrus
                Array.from(intruderSelectionDiv.children).forEach(cell => {
                    if (cell.dataset.motif === correctIntruderMotif) {
                        cell.classList.add('correct');
                    }
                });
                
                if (lives <= 0) {
                    soundGameOver.play();
                    messageDisplay.textContent = `Game Over ! Votre score final est ${score}.`;
                    messageDisplay.style.color = '#e74c3c'; // Rouge plus fonc√© pour Game Over
                    if (score > bestScore) {
                        bestScore = score;
                        localStorage.setItem('bestScore', bestScore);
                        bestScoreDisplay.textContent = `Nouveau meilleur score : ${bestScore}`;
                        bestScoreDisplay.style.display = 'block';
                    }
                    restartButton.style.display = 'inline-block';
                    restartButton.disabled = false;
                } else {
                    nextRoundButton.textContent = "Continuer"; // Changer le texte pour continuer apr√®s une erreur
                    nextRoundButton.style.display = 'inline-block';
                    nextRoundButton.disabled = false;
                    restartButton.style.display = 'inline-block'; // Option de red√©marrer √† tout moment
                    restartButton.disabled = false;
                }
            }
        }

        // --- Gestion des boutons et initialisation ---

        function disableButtons() {
            startIntroButton.disabled = true;
            nextRoundButton.disabled = true;
            restartButton.disabled = true;
        }

        function enableButtons() {
            startIntroButton.disabled = false;
            nextRoundButton.disabled = false;
            restartButton.disabled = false;
        }

        function updateGameStatus() {
            let hearts = '‚ù§Ô∏è'.repeat(lives) + 'üñ§'.repeat(INITIAL_LIVES - lives); // C≈ìurs pleins/vides
            gameStatusDisplay.textContent = `Score: ${score} | Vies: ${hearts}`;
            bestScoreDisplay.textContent = `Meilleur score : ${bestScore}`;
        }

        function resetGame() {
            level = 1;
            numUniqueMotifs = 3;
            memoTime = 8;
            score = 0;
            lives = INITIAL_LIVES;
            levelInfo.textContent = `Niveau : ${level}`;
            messageDisplay.textContent = ''; // Vide le message apr√®s red√©marrage
            timerDisplay.textContent = '';
            gameGridMemo.style.display = 'none';
            intruderSelectionDiv.style.display = 'none';
            clearInterval(timerInterval); // Arr√™te tout timer en cours
            
            // R√©initialise l'affichage et les boutons pour l'√©cran d'intro
            introScreen.style.display = 'flex';
            gameStatusDisplay.style.display = 'none';
            levelInfo.style.display = 'none';
            nextRoundButton.style.display = 'none';
            restartButton.style.display = 'none';
            bestScoreDisplay.style.display = 'block'; // Affiche toujours le meilleur score sur l'√©cran d'accueil
            nextRoundButton.textContent = "Niveau Suivant"; // S'assurer que le texte du bouton est correct pour le prochain round

            updateGameStatus(); // Met √† jour l'affichage des vies/score
            enableButtons(); // Active les boutons de l'√©cran d'accueil
        }

        // √âcouteurs d'√©v√©nements
        startIntroButton.addEventListener('click', startMemorizationPhase);
        nextRoundButton.addEventListener('click', startMemorizationPhase);
        restartButton.addEventListener('click', resetGame);

        // Initialisation au chargement
        document.addEventListener('DOMContentLoaded', () => {
            initialLivesSpan.textContent = INITIAL_LIVES; // Met √† jour le nombre de vies dans les r√®gles
            updateGameStatus(); // Met √† jour l'affichage initial du score/vies
            bestScoreDisplay.style.display = 'block'; // Affiche le meilleur score d√®s le d√©but
            // S'assurer que le bouton de d√©marrage est actif
            startIntroButton.disabled = false;
        });
    </script>
</body>
</html>
